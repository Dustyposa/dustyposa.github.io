<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="一些经验的记录。"><meta name="author" content="Dusty Posa"><meta name="keywords" content="python,python3,process,script"><title>从requests请求重试到万能重试装饰器 - Posaのにわ</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>Posaのにわ</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/">分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta"><i class="fas fa-calendar-alt" aria-hidden="true"></i> 星期二, 四月 7日 2020, 10:02 上午</p><p class="mt-1"><span class="post-meta"><i class="far fa-chart-bar"></i> 5k 字 </span><span class="post-meta"><i class="far fa-clock"></i> 20 分钟</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><p class="note note-warning">本文最后更新于：星期一, 四月 13日 2020, 6:02 早上</p><div class="markdown-body"><h2 id="从requests请求重试到万能重试装饰器"><a href="#从requests请求重试到万能重试装饰器" class="headerlink" title="从requests请求重试到万能重试装饰器"></a>从requests请求重试到万能重试装饰器</h2><p>重试，在编写代码的过程中，是一个很常见的需求。<br>比如：</p><ol><li>请求重试（例如：超时）</li><li>文件占用</li><li>IO阻塞等待</li></ol><p>那么，我们如何编写重试的代码呢？<br>本文将从请求重试开始，带大家从简单的超时重试，最后编写到万能错误重试。</p><blockquote><p>主要涉及内容：</p><ul><li>requests adapter</li><li>函数装饰器</li><li>类装饰器</li></ul></blockquote><p>话不多说，start！</p><p><strong>因为我们需要从 <code>requests</code> 请求重试开始，为了方便测试请求，我们用 <code>flask</code> 编写一个简单的服务器，用于请求测试。</strong></p><h2 id="准备请求服务器"><a href="#准备请求服务器" class="headerlink" title="准备请求服务器"></a>准备请求服务器</h2><p>服务器的功能比较简单，用来查看请求次数和观察是否重试成功，<code>flask_server.py</code>代码如下：</p><pre><code class="python">from time import sleep

from flask import Flask, jsonify, Response

app: Flask = Flask(__name__)

retry_count: int = 0  # 用于重试请求的计数


@app.route(&quot;/api/retry&quot;, methods=[&quot;GET&quot;])
def retry_api() -&gt; Response:
    &quot;&quot;&quot;
    延时 1s 的请求接口， 响应时间 &gt; 1s。
    :return:
    &quot;&quot;&quot;
    global retry_count
    retry_count += 1
    print(f&quot;这是第{retry_count}次请求&quot;)
    if retry_count &lt; 3:
        sleep(1)
    else:
        retry_count = 0  # 计数清零
    return jsonify({&quot;msg&quot;: &quot;已经三次了哦！&quot;})


if __name__ == &#39;__main__&#39;:
    app.run()
</code></pre><p>代码比较简单，由于没有找到好用的<code>flask</code>上下文来完成计数需求，这里为了简单操作，就直接应用了全局变量来计数（仅用于测试，未加锁），而没有使用<code>redis</code>数据库来计数了。</p><p>编写好之后，我们运行代码即可。这样，我们用来测试重试的服务器就准备好了。</p><p>接下来，我们先来看看一般的 <code>requests</code> 超时请求如何实现。</p><h2 id="1-requests-请求重试（常见版本）"><a href="#1-requests-请求重试（常见版本）" class="headerlink" title="1.requests 请求重试（常见版本）"></a>1.<code>requests</code> 请求重试（常见版本）</h2><p>我们用 <code>try...except...</code> 语句捕捉<code>timeout</code>错误。进行循环重试即可。我们编写一个函数 <code>get_data</code>，<code>normal.py</code>代码如下：</p><pre><code class="python">from typing import Dict, Any

import requests

BaseDictData = Dict[str, Any]


def get_data(url: str, max_retry: int = 0, time_out: float = 3., **kwargs) -&gt; BaseDictData:
    &quot;&quot;&quot;自动重试 timeout 错误 的方法&quot;&quot;&quot;
    params: BaseDictData = kwargs.get(&quot;params&quot;, {})  # 不管你传了什么奇怪的东西， 我只收这个
    headers: BaseDictData = kwargs.get(&quot;headers&quot;, {})  # 同上
    for i in range(max_retry + 1):
        &quot;&quot;&quot;进行最大重试次数的遍历&quot;&quot;&quot;
        try:
            response: requests.Response = requests.get(
                url=url,
                params=params,
                headers=headers,
                timeout=time_out,
            )
        except requests.ReadTimeout:
            print(f&quot;第{i + 1}次请求失败，正在重试。&quot;)
        else:
            return response.json()  # 没有错误，直接返回

    print(f&quot;{max_retry + 1} 次请求都失败了，返回空值，便于后续逻辑处理。。。&quot;)
    return {}


if __name__ == &#39;__main__&#39;:
    print(get_data(&quot;http://localhost:5000/api/retry&quot;, max_retry=1, time_out=.01))
</code></pre><p>在该函数中，我们利用 <code>requests</code> 库本身的 <code>timeout</code> 参数进行错误捕捉。整体比较简单，设计逻辑即：</p><pre class="mermaid">graph LR
A[请求] -- 超时重试--> A
A --成功--> B[处理成功后的数据]
A--超过最大重试次数-->C[返回空数据便于后续逻辑处理]</pre><p>如果超时，那么就会引发错误，然后继续请求，用<code>for</code>循环来处理循环重试，更加简洁。</p><p>超过最大次数，就返回空数据，成功，返回成功数据。</p><p>代码段注意要点：<br><strong><code>try...except...</code></strong> 语句</p><pre><code class="python">try:
    ...  # 需要捕捉异常的代码
except xxx:
    ...  # 发生异常处理逻辑
else:
    ...  # 如果 try 成功执行，就执行else，否则跳过else
finally:
    ...  # 一定会执行该语句块</code></pre><p>我们在 <code>try</code> 语句块中只运行了一行代码，因为这次捕捉只针对这行代码可能会引起的错误，做到<strong>精确捕捉异常</strong>。</p><p>如果 <code>try</code> 语句块中的代码太多的话（比如要做多件事情），错误调试和错误处理都比较麻烦，因为我们不知道是哪行引起的错误，需要加（<code>print</code>） 或者 （<code>debug</code>）来查看具体错误原因，并且不要担心使用<code>try...except...</code>语句，<code>python</code>中的异常处理代价是很小的，异常处理也是很常见的。</p><p>而<code>else</code>语句块，就是正常逻辑的补充处理。</p><p><strong>TIPS:</strong><br><strong>在 <code>for...in...:</code>语句中也有<code>else</code>语句块，对完成循环后进行补充。</strong></p><details><summary><code>for...in...</code>示例</summary><p>比如，我们要循环检测一个列表<code>check_data: List[Union[int, str]] = [1, 2, 3, 4]</code>是否有字符串，如果有字符串我们就不进行后续处理，如过没有字符串，我们就调用 <code>handle_data</code> 函数。</p><p>为了满足上面的需求，通常，我们都会写一个 <code>tag/signal</code>来标注状态，例如下面的代码：</p><pre><code class="python">has_string: bool = False
for data in check_data:
    if isinstance(data, str):
        has_string = True
        break

if not has_string:
    # 没有字符串的情况下
    handle_data() </code></pre><p>有了 <code>else</code> 我们就可以简化代码，如下：</p><pre><code class="python">for data in check_data:
    if isinstance(data, str):
        break
else:
    # 没有字符串的情况下
    handle_data() </code></pre><p>这样逻辑就可以更清晰一些。另外， <code>while 循环</code>也支持 <code>else</code> 语句，这里就不重复演示了。</p></details><h4 id="查看效果。"><a href="#查看效果。" class="headerlink" title="查看效果。"></a>查看效果。</h4><p>我们调用 <code>print(get_data(&quot;http://localhost:5000/api/retry&quot;, max_retry=2, time_out=.01))</code><br>客户端结果:</p><pre><code>第1次请求失败，正在重试。
第2次请求失败，正在重试。
{&#39;msg&#39;: &#39;已经三次了哦！&#39;}</code></pre><p>服务端结果：</p><pre><code>这是第1次请求
这是第2次请求
这是第3次请求</code></pre><p>这里 <code>max_retry</code> 为最大<strong>重试</strong>次数，所以最大请求次数为<code>1+max_retry</code>。</p><p>我们调用<code>print(get_data(&quot;http://localhost:5000/api/retry&quot;, max_retry=1, time_out=.01))</code><br>客户端结果:</p><pre><code>第1次请求失败，正在重试。
第2次请求失败，正在重试。
2 次请求都失败了，返回空值，便于后续逻辑处理。。。
{}</code></pre><p>服务端结果：</p><pre><code>这是第1次请求
这是第2次请求</code></pre><p>可以看出，整体效果也是符合预期的，没有多大问题。<br>接下来，我们利用<code>requests</code>自带的请求重试器。</p><h2 id="2-requests-adapter-重试"><a href="#2-requests-adapter-重试" class="headerlink" title="2. requests adapter 重试"></a>2. <code>requests adapter</code> 重试</h2><p><code>requests</code> 有一个 <code>HTTPAdapter</code> 对象，看名字就有一种可以给 <code>requests</code>加特效的感觉。</p><p>不过 <code>HTTPAdapter</code> 主要可以实现：</p><blockquote><p>创建连接池，（类似线程池，进程池，连接可服用）<br>限定连接池数量（避免连接数过多（线程过多））。<br>重试请求。</p></blockquote><p><code>requests_built.py</code>代码如下：</p><pre><code class="python">import requests
from requests.adapters import HTTPAdapter

from normal import BaseDictData


def get_data(url: str, max_retry: int = 0, time_out: float = 1., **kwargs) -&gt; BaseDictData:
    &quot;&quot;&quot;
    自动重试 timeout 错误 的方法, 用 requests 自带轮子完成！
    :param url: 请求的 url
    :param max_retry: 最大重试次数
    :param time_out: 超时重试时间
    :param kwargs: 可选命名参数
    :return: BaseDictData
    &quot;&quot;&quot;
    session: requests.Session = kwargs.get(&quot;session&quot;, requests.Session())  # 获取session 或者新建 session
    params: BaseDictData = kwargs.get(&quot;params&quot;, {})  # 不管你传了什么奇怪的东西， 我只收这个
    headers: BaseDictData = kwargs.get(&quot;headers&quot;, {})  # 同上
    adapter: HTTPAdapter = HTTPAdapter(max_retries=max_retry)  # 初始自带处理额外操作的适配器
    session.mount(&quot;http://127.0.0.1&quot;, adapter=adapter)  # 给我们的 session 安装上 adapter, 第一个参数为主机，代表对于哪台主机的请求需要装上适配器
    try:
        response: requests.Response = session.get(
            url,
            params=params,
            headers=headers,
            timeout=time_out
        )
    except requests.ConnectTimeout:
        print(f&quot;{max_retry + 1}次请求都失败了，即将返回空值，请耐心等待...&quot;)
    else:
        session.close()  # 关闭 session, 源码主要是清除所有装配器
        return response.json()
    return {}


if __name__ == &#39;__main__&#39;:
    res = get_data(&quot;http://127.0.0.1:5000/api/retry&quot;, 3)
    print(res)</code></pre><p>整体代码也比较简单，在常规请求之上，主要加了两行代码。就是给 <code>Session</code> 对象用 <code>mount</code> 方法给对于 <code>http://127.0.0.1</code>的主机请求加上了 <code>adapter</code>，该<code>adapter</code>对象增加了最大的重试次数。</p><p>PS：</p><ul><li>我们也可以用 <code>http://</code> 来表示对于所有<code>http请求</code>的主机都装上<code>adapter</code></li><li>我们也可以针对多个请求主机<pre><code class="python">session.mount(&quot;http://127.0.0.1&quot;, adapter=adapter)
session.mount(&quot;https://github.com&quot;, adapter=adapter)</code></pre>运行结果（服务器端相似，之后的展示只展示客户端）:</li></ul><p><code>print(get_data(&quot;http://127.0.0.1:5000/api/retry&quot;, 2))</code></p><p>客户端：</p><pre><code>{&#39;msg&#39;: &#39;已经三次了哦！&#39;}</code></pre><p><code>print(get_data(&quot;http://127.0.0.1:5000/api/retry&quot;, 1))</code></p><p>客户端：</p><pre><code>2次请求都失败了，即将返回空值，请耐心等待...
{}</code></pre><h2 id="3-构造请求重试装饰器"><a href="#3-构造请求重试装饰器" class="headerlink" title="3.构造请求重试装饰器"></a>3.构造请求重试装饰器</h2><p>通过前两个方法来看，我们知道主要的重试方式有两种：</p><ol><li>循环请求</li><li><code>requests</code>自带的适配器</li></ol><p>但是呢，这两种，可复用性不太强，我们升级一下，用装饰器来试试。（当然，也有其他复用方法，比如创建重试专用对象，或者加入重试调度器）</p><p>当然装饰器的写法，我们至少也可以写出两种版本。</p><details><summary>python装饰器原理速览</summary><p>统计函数运行时间的装饰器<code>derector.py</code>：</p><pre><code class="python">import time


def count_fun_time(func):
    def wrapper(*arg, **kwargs):
        start_time = time.time()
        res = func(*arg, **kwargs)
        print(f&quot;函数总共运行了{time.time() - start_time:.2f}s&quot;)
        return res
    return wrapper


def my_function(time_wait: int = 3):
    time.sleep(time_wait)
    print(&quot;运行结束&quot;)


my_function = count_fun_time(my_function)
my_function()
my_function(4)</code></pre><p>上面的代码示例为原始版本，就是利用函数的<strong>闭包特性(闭包函数)</strong>，在函数内部调用函数，同时进行其他操作即可。</p><p>然后将<strong>新函数重新命名为原函数的名字</strong>。</p><p>运行结果如下：</p><pre><code> 运行结束
函数总共运行了3.00s
运行结束
函数总共运行了4.00s</code></pre><p>当然，简便的python不会让你这样写，于是，语法糖便出现了。</p><p>我们的计算运行时间的装饰器函数 <code>count_fun_time</code>不变，</p><p>只需要在<code>my_funtion</code>上面加上糖<code>@count_fun_time</code> 即可。</p><pre><code class="python">@count_fun_time
def my_function(time_wait: int = 3):
    time.sleep(time_wait)
    print(&quot;运行结束&quot;)

my_function()
my_function(4)</code></pre><p>从上面的代码我们也可以，装饰器函数使用语法糖之后更加的<strong>优雅和易懂。</strong></p><p>但是在装饰器装饰元函数之后，元信息有所损坏(例如:<code>my_function.__name__</code>缺失)，需要进行改良（改良方法在下文中出现。）</p></details><h3 id="3-1-构造被装饰的函数get-data"><a href="#3-1-构造被装饰的函数get-data" class="headerlink" title="3.1 构造被装饰的函数get_data"></a>3.1 构造被装饰的函数<code>get_data</code></h3><p>既然是装饰器，那么我们先定义一个<strong>请求函数</strong>，当作被装饰的函数。</p><p>代码如下：</p><pre><code class="python">def get_data(url: str, time_out: float = 3., **kwargs) -&gt; BaseDictData:
    &quot;&quot;&quot;
    自动重试 timeout 错误 的方法, 用 requests 自带轮子完成！
    :param url: 请求的 url
    :param time_out: 超时重试时间
    :param kwargs: 可选命名参数
    :return: BaseDictData
    &quot;&quot;&quot;
    session: requests.Session = kwargs.get(&quot;session&quot;, requests.Session())  # 获取session 或者新建 session
    params: BaseDictData = kwargs.get(&quot;params&quot;, {})  # 不管你传了什么奇怪的东西， 我只收这个
    headers: BaseDictData = kwargs.get(&quot;headers&quot;, {})  # 同上
    with session.get(url, params=params, headers=headers, timeout=time_out) as response:
        return response.json()</code></pre><p>代码很简单，为了通用性（因为有两种装饰器，循环和<code>adapter</code>)，我们选择使用 <code>Session对象</code>来做请求。</p><p>好了，开始装饰器的正题。</p><h3 id="3-1-循环重试装饰器"><a href="#3-1-循环重试装饰器" class="headerlink" title="3.1  循环重试装饰器"></a>3.1 循环重试装饰器</h3><p>首先，我们先构思一下，我们的装饰器要完成什么。</p><p><code>get_data</code> 这个函数为内部函数，可能<code>timeout</code>，我们复用之前写的错误即可，然后捕捉该错误。</p><p>接下来，如果运行函数出错，我们就进行循环重试。</p><h4 id="3-1-1-基本循环重试装饰器"><a href="#3-1-1-基本循环重试装饰器" class="headerlink" title="3.1.1 基本循环重试装饰器"></a>3.1.1 基本循环重试装饰器</h4><p>整体代码如下：</p><pre><code class="python">from functools import wraps

def retry(func):
    @wraps(func)  # 保留被装饰函数的元信息
    def closure(*args, **kwargs) -&gt; BaseDictData:
        for i in range(3):
            try:
                res = func(*args, **kwargs)
            except (requests.ConnectTimeout, requests.ReadTimeout):
                print(f&quot;第{i + 1}次重试。&quot;)
            else:
                return res
        return {}
    return closure

@retry
def get_data(...):
    --skip--</code></pre><p>这里我们利用 <code>@wraps</code> 保留元函数信息。这样我们就可以看到完整的被装饰后函数的信息。例如:<code>get_data.__name__， 函数签名，函数文档等</code>。</p><p>运行结果类似，我们就不展示了，内容有点重复。<br>整体逻辑其实和<code>for...in...</code>循环的重试基本一致，但是我们封装成了一个装饰器函数，这样我们就可以到处用！简直不能太方便。<br>于此同时，我们可以看到 <code>except (requests.ConnectTimeout, requests.ReadTimeout)</code> 这个地方！可以操作一下，假如错误类型是变量，那是不是就可以捕捉想捕捉的任意错误了。 并且，最大重试次数我们是写死的，这里肯定也能写成变量。那么，如何书写呢？</p><p><strong>再加一层闭包。</strong> 没错，我们再套一层函数即可。</p><h4 id="3-1-2-任意错误循环重试的函数装饰器"><a href="#3-1-2-任意错误循环重试的函数装饰器" class="headerlink" title="3.1.2 任意错误循环重试的函数装饰器"></a>3.1.2 任意错误循环重试的函数装饰器</h4><p><code>strong_retry</code>代码如下:</p><pre><code class="python">def strong_retry(
        max_retry: int = 3,
        exception: Tuple[BaseException] = (
                requests.ConnectTimeout,
                requests.ReadTimeout,
        )
):
    &quot;&quot;&quot;
    万能函数重试装饰器诞生！
    :param max_retry: 最大重试次数
    :param exception: 捕捉错误类型
    :return:
    &quot;&quot;&quot;

    def retry(func):
        @wraps(func)  # 保留被装饰函数的元信息
        def closure(*args, **kwargs) -&gt; BaseDictData:
            for i in range(max_retry + 1):
                try:
                    res = func(*args, **kwargs)
                except exception:
                    print(f&quot;第{i + 1}次重试。&quot;)
                else:
                    return res
            return {}
        return closure
    return retry

@strong_common_retry(max_retry=4, exception=(requests.ReadTimeout,))
def get_data(...):
    # 装饰函数，最大重试数为 4，</code></pre><p>再在外层函数帮助我们传入参数，并在原装饰器函数内部使用参数即可。</p><p>这样，我们就能针对<strong>某些错误进行重试</strong>操作了！（有一个模块 <code>retrying</code>, 也能进行错误重试，我们轻松的实现了一个简易版本！）</p><blockquote><p>例如:<br>@strong_common_retry(exception=(ValueError, NameError)) # 针对这两个错误进行捕捉<br>但是有一点需要注意，千万不要用 <code>exception=(BaseException,)</code> !!!!这样连<kbd>Ctrl/Command</kbd> + <kbd>C</kbd> 都失效了！（引发<code>KeyboardInterrupt</code>错误的方法）</p></blockquote><p>到这里完了吗？当然没有，因为我们还能再优化一下，当装饰器带有参数时，装饰器函数嵌套层数太多。影响阅读，这时候，祭出我们的装饰器神器<code>wrapt</code>。(需要 <code>pip install wrapt</code>)<br>使用后代码如下:</p><pre><code class="python">def strong_common_retry(max_retry, exception):
    @wrapt.decorator  # 保留被装饰函数的元信息
    def wrapper(wrapped, instance, args, kwargs) -&gt; BaseDictData:
        &quot;&quot;&quot;

        :param wrapped: 
        :param instance:如果被装饰者为普通类方法，该值为类实例
                        如果被装饰者为 classmethod 类方法，该值为类
                        如果被装饰者为类/函数/静态方法，该值为 None 
        :param args: 
        :param kwargs: 
        :return: 
        &quot;&quot;&quot;
        for i in range(max_retry + 1):
            try:
                res = wrapped(*args, **kwargs)
            except exception:
                print(f&quot;第{i + 1}次重试。&quot;)
            else:
                return res
        return {}
    return wrapper</code></pre><p>这样快速地就<strong>减少了装饰器函数的嵌套层数</strong>，同时还能解决对类中的函数装饰器绑定对象的问题。</p><p>所以当需要编写装饰器函数的时候，不妨试试<code>wrapt</code>吧！绝对是你的好帮手！</p><p>循环重试搞定了，函数装饰器也讲的差不多了，但是我们还有适配器装饰器没有讲，怎么办！当然换点花样，类的装饰器 <strong>start</strong>。</p><h3 id="3-2-Session适配器重试"><a href="#3-2-Session适配器重试" class="headerlink" title="3.2 Session适配器重试"></a>3.2 <code>Session</code>适配器重试</h3><p>这次，我们的装饰器需要实现对原请求函数中的 <code>Session对象</code> 添加适配器，但是我们需要用类来实现。</p><p>但是类怎么实现呢？装饰器函数比较好理解，调用函数<code>func()</code>，我们就能完成原函数的替代。但是类怎么调用呢？ 这时候，就需要 python 给我们提供的魔术方法（双下方法）<code>__call__</code> 来实现了！</p><h4 id="3-2-1-类装饰器原理"><a href="#3-2-1-类装饰器原理" class="headerlink" title="3.2.1 类装饰器原理"></a>3.2.1 类装饰器原理</h4><p>其实<code>__call__</code>方法理解比较简单，就是可以让实例话的对象直接调用。Examples are as follows:</p><pre><code class="python">class MySpider:
    def __call__(self):
        print(f&quot;{self.__class__.__name__} is calling&quot;)


MySpider()()</code></pre><p>输出结果如下：<br><code>MySpider is calling</code></p><p>这样我们就成功调用了实例化对象。</p><p>利用这个特性，我们就可以自然地写出装饰器类。</p><pre><code class="python">class MySpider:
    def __init__(self, func: Callable):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(&quot;reset for on second&quot;)
        time.sleep(1)
        res_data = self.func(*args, **kwargs)
        return res_data

    def at_once_run(self, *args, **kwargs):
        print(&quot;now, run the function&quot;)
        return self.func(*args, **kwargs)

def spider():
    print(&quot;正在抓取&quot;)

spider = MySpider(spider)
spider()</code></pre><p>输出结果如下：</p><pre><code>reset for on second
正在抓取</code></pre><p>与装饰器函数很像，核心就是 <code>__call__</code> 方法。<br>那么类的装饰器有什么好处呢？</p><blockquote><ol><li>没有复杂的函数嵌套，阅读代码时更加清晰，更加pythonic。</li><li>可以增加许多额外的属性，更好的管理装饰器对象。</li><li>可以给装饰器添加更多的功能。</li></ol></blockquote><p>功能怎么加呢？别忘了我们上个代码段还有一个函数没有使用！话不多说，直接看看怎么用。<br>原始用法：</p><pre><code class="python">spider = MySpider(spider).at_once_run
spider()</code></pre><p>但是看起来并不优雅，每次也比较麻烦。<br>语法糖用法：</p><pre><code class="python">@MySpider
def spider():
    ...
spider.at_once_run()</code></pre><p>运行结果如下：</p><pre><code>now, run the function
正在抓取</code></pre><p>就像加了魔法一样，我们的原始函数<code>spider</code>变得异常强大，还增加了许多新的功能！</p><p>好了，把类当作装饰器的简单原理如上。接下来，我们就展示一下，用类装饰器为<code>Session</code>对象撞上翅膀！</p><h4 id="3-2-2-类装饰器实战"><a href="#3-2-2-类装饰器实战" class="headerlink" title="3.2.2 类装饰器实战"></a>3.2.2 类装饰器实战</h4><p>代码如下：</p><pre><code class="python">class RequestsRetry:
    def __init__(self, max_retry: int, func: Callable) -&gt; None:
        &quot;&quot;&quot;需要注意。被装饰的函数是最后传入的。&quot;&quot;&quot;
        self.max_retry = max_retry
        functools.wraps(func)(self)  # 保留原函数的元信息
        self.func = func

    def __call__(self, *args, **kwargs) -&gt; BaseDictData:
        &quot;&quot;&quot;装饰器处理逻辑函数&quot;&quot;&quot;
        session: requests.Session = kwargs.get(&quot;session&quot;, requests.Session())  # 获取session 或者新建 session
        max_retry: requests.Session = kwargs.get(&quot;max_retry&quot;)  # 获取 max_retry
        adapter: HTTPAdapter = HTTPAdapter(max_retries=max_retry)  # 初始自带处理额外操作的适配器
        session.mount(&quot;http://&quot;, adapter=adapter)  # 给我们的 session 安装上 adapter, 第一个参数为前缀，代表哪种请求需要装上适配器
        kwargs.update(session=session)  # 更新 session， 如果没有传session，就将带适配器的 session 传入命名参数
        try:
            response: BaseDictData = self.func(*args, **kwargs)
        except requests.ConnectTimeout:
            print(f&quot;{max_retry}次请求都超时了，即将返回空值，请耐心等待返回空值&quot;)
            return {}
        else:
            return response

    def itself(self, *args, **kwargs) -&gt; BaseDictData:
        &quot;&quot;&quot;不做处理，调用本身&quot;&quot;&quot;
        return self.func(*args, **kwargs)

    def __get__(self, instance, owner) -&gt; object:
        &quot;&quot;&quot;实现该方法后，可以将装饰器器用于类的函数的装饰。&quot;&quot;&quot;
        if instance is None:
            return self
        return types.MethodType(self, instance)  # 如果有参数，就绑定至self


def retry(max_retry: int = 3):
    &quot;&quot;&quot;装饰器包装，增加请求重试参数。&quot;&quot;&quot;
    # 此处为了避免定义额外函数，直接使用 functools.partial 帮助构造 RequestsRetry 实例
    return functools.partial(RequestsRetry, max_retry)



@retry(max_retry=3)
def get_data(url: str, time_out: float = 3., **kwargs) -&gt; BaseDictData:
    --skip--</code></pre><p><code>__init__</code>方法比较简单，接受了一个额外参数<code>max_retry</code>，然后利用<code>functools</code>保留<strong>元函数信息</strong>，和函数装饰器类似。<br>然后核心代码为<code>__call__</code>中的部分我们利用<code>kwargs</code>获取传入的<code>Session</code>对象，然后再将该对象加上<strong>适配器</strong>，然后还给<code>kwargs</code>，即可。这样就加上了最大重试次数，也就自带重试功能了。比<code>for...in...</code>更加简单，逻辑更加清晰，但是缺点就是只能针对<code>Session</code>对象的错误，不能针对万能错误进行重试。</p><p>最后<code>retry</code>函数，用了一个<code>partial</code>函数<strong>辅助构造</strong>（如果不实用该函数，为装饰器增加<code>max_retry</code>参数较为麻烦，此处不展开说明方法，感兴趣可以自己尝试，欢迎和我交流）类装饰器，顺便给装饰器换了个名字:)。</p><p>额外的东西：</p><blockquote><p>我们为了保留元函数，增加了<code>itself</code>方法，该方法就是不增加额外功能的装饰器（<strong>保持原函数逻辑调用</strong>）。<br>有一个<code>__get__</code>方法，当实例化对象调用方法时，实质就会先调用该函数<strong>获取绑定在实例化对象上的方法</strong>。类的装饰器装饰其他类中的函数时，需要补上该方法，否则类中的函数不能使用装饰器。此处我们利用该方法，<strong>重新构造绑定逻辑。</strong></p></blockquote><p>输出结果和上文中的输出一致，这里就不重复展示结果了。<br>到这里，我们的所有重试方法就讲解完毕啦，相信你一定也收获满满。<br>老规矩，我们再总结一下本文所讲内容：</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>1. <code>for...in...</code>循环实现<code>requests</code>请求重试<br>2. 利用<code>adapter</code> 实现<code>requests</code>请求重试<br>3. 装饰器函数原理<br>4. 利用函数装饰器实现<code>requests</code>请求重试到万能重试装饰器<br>5. 类装饰器简单原理<br>6. 类装饰器实战<code>requests</code>请求重试</strong></p><p><a href="https://github.com/Dustyposa/goSpider/tree/master/python_advance/requests%E8%AF%B7%E6%B1%82%E9%87%8D%E8%AF%95" target="_blank" rel="noopener">完整代码地址</a></p></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/advance/">advance</a> &nbsp; </span>&nbsp;&nbsp; <span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/python/">python</a> <a class="hover-with-bg" href="/tags/decorator/">decorator</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/2020/04/07/%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB(tr)/"><i class="fa fa-chevron-left"></i> <span class="hidden-mobile">异步网络爬虫</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/2020/04/07/%E4%BD%BF%E7%94%A8python%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/"><span class="hidden-mobile">使用python客户端和服务器的功能测试实例</span> <span class="visible-mobile">下一篇</span> <i class="fa fa-chevron-right"></i></a></div></div></div><div class="comments" id="comments"><script defer src="https://utteranc.es/client.js" repo="Dustyposa/utterances_comments" issue-term="pathname" label="✨💬✨" theme="github-light" crossorigin="anonymous"></script></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script><script>$(document).ready(function(){var s=$("#navbar").height(),c=$("#toc"),t=$("#board-ctn"),o=t.offset().top,i=2*o+t.height();$(window).scroll(function(){var t=$("#toc-start").offset().top-s,o=document.body.scrollTop+document.documentElement.scrollTop;t<=o&&o<=i?c.css({display:"block",position:"fixed",top:s}):o<=t?c.css({position:"",top:""}):i<o&&c.css("display","none")}),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-o}),0<$(".toc-list-item").length&&$("#toc > p").css("visibility","visible");var l=t.css("margin-right");$("#toc-ctn").css({right:l})})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  "),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","从requests请求重试到万能重试装饰器&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>