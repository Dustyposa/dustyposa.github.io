<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="一些经验的记录。"><meta name="author" content="Dusty Posa"><meta name="keywords" content="python,python3,process,script"><title>奇妙的对象模型及存储数据模型的技巧 - Posaのにわ</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>Posaのにわ</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/">分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(https://i.loli.net/2020/04/14/smYH5uD8Pb7k4oI.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><p class="mt-3 post-meta"><i class="fas fa-calendar-alt" aria-hidden="true"></i> 星期二, 四月 7日 2020, 9:43 上午</p><p class="mt-1"><span class="post-meta"><i class="far fa-chart-bar"></i> 3.4k 字 </span><span class="post-meta"><i class="far fa-clock"></i> 15 分钟</span></p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><p class="note note-warning">本文最后更新于：星期三, 一月 13日 2021, 10:56 上午</p><div class="markdown-body"><h3 id="方便的数据结构之"><a href="#方便的数据结构之" class="headerlink" title="方便的数据结构之"></a>方便的数据结构之</h3><h2 id="namedtuple-与-dataclass-以及-类结构进阶的基本使用"><a href="#namedtuple-与-dataclass-以及-类结构进阶的基本使用" class="headerlink" title="namedtuple 与 dataclass 以及 类结构进阶的基本使用"></a>namedtuple 与 dataclass 以及 类结构进阶的基本使用</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#namedtuple">namedtuple</a></li><li><a href="#dataclass">dataclass</a></li><li><a href="#Python对象模型">Python对象模型</a></li><li><a href="#一些额外的补充">补充</a></li></ul><p>其中，<code>nametuple</code> 和 <code>dataclasses</code> 个人觉得比较相似，这两个都是用来保存数据的，我们一起来看看区别吧。</p><p>在python内置模块 <code>collections</code> 中，有一个类为 <code>nametuple</code> 看名字我们可以大概猜出意思，有名字的元组。那么，这个 namedtuple 到底能做什么呢？<br>我们通过代码来看一下,</p><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><pre><code class="python">from collections import namedtuple  # 导入模块</code></pre><pre><code class="python">food = namedtuple(&quot;Foods&quot;, [&quot;fruit&quot;, &quot;price&quot;])  # 初始化一个对象，但是并不能直接使用。我们需要向其中加入数据。
food</code></pre><pre><code>__main__.Foods</code></pre><pre><code class="python">data_1 = food(fruit=&quot;apple&quot;, price=123)
data_1</code></pre><pre><code>Foods(fruit=&#39;apple&#39;, price=123)</code></pre><pre><code class="python"># 访问数据
print(data_1.fruit)
print(data_1.price)</code></pre><pre><code>apple
123</code></pre><pre><code class="python"># 尝试更改数据
data_1.fruit = &quot;banana&quot;</code></pre><pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-5-acfec753951a&gt; in &lt;module&gt;
      1 # 尝试更改数据
----&gt; 2 data_1.fruit = &quot;banana&quot;


AttributeError: can&#39;t set attribute</code></pre><h4 id="基本操作就是如上，可以看到我们通过-namedtuple-可以获得一个对象，并且可以通过属性访问"><a href="#基本操作就是如上，可以看到我们通过-namedtuple-可以获得一个对象，并且可以通过属性访问" class="headerlink" title="基本操作就是如上，可以看到我们通过 namedtuple 可以获得一个对象，并且可以通过属性访问."></a>基本操作就是如上，可以看到我们通过 <code>namedtuple</code> 可以获得一个对象，并且可以通过属性访问.</h4><h4 id="并且与元组-tuple-相同，不能更改属性，也就是对象一旦创立，遍不能更改，即不可变性依然保持着。"><a href="#并且与元组-tuple-相同，不能更改属性，也就是对象一旦创立，遍不能更改，即不可变性依然保持着。" class="headerlink" title="并且与元组 tuple 相同，不能更改属性，也就是对象一旦创立，遍不能更改，即不可变性依然保持着。"></a>并且与元组 <code>tuple</code> 相同，不能更改属性，也就是对象一旦创立，遍不能更改，即不可变性依然保持着。</h4><blockquote><p>那么问题来了，这玩意创建步骤也比较麻烦。到底有什么用呢？</p></blockquote><h4 id="提高代码可读性！！！"><a href="#提高代码可读性！！！" class="headerlink" title="提高代码可读性！！！"></a><strong>提高代码可读性！！！</strong></h4><p>你没看错，就是提高代码可读性。<br>举个栗子：<br>你需要用一个数据结构保存不会变的东西，我们假设这个东西是水果。这个东西需要保存两个值，假设值分别为: apple 13。<br>我们看看元组怎么做：</p><pre><code class="python">data = (&quot;apple&quot;, 13)
data</code></pre><pre><code>(&#39;apple&#39;, 13)</code></pre><p>emmm….对，很简单！一步就初始化出来了，但是我们要访问怎么办呢？这时候就只能用索引或者遍历了，如下：</p><pre><code class="python">print(data[0])
print(data[1])
for d in data:
    print(d)</code></pre><pre><code>apple
13
apple
13</code></pre><p><strong>这时候就有问题了，如果这是你自己写的代码还好，知道数据在哪个位置(但是数据多了，有时也会忘记)，但是如果是别人来看的话，可能就比较懵逼了，需要不断的查看代码段。</strong><br>别怕，我们有 <code>namedtuple</code> ，来，我们看看 <code>namedtuple</code> 有什么特效。<br>数据，两个值，那么 这两个值肯定有含义的对吧， 对吧？（不要抬杠哦！）， 我们假设含义是 水果种类 和 价格<br>那么我们就可以取两个名字，为了方便认识，我们就叫 <code>fruit</code> 和 <code>name</code>吧。（不要告诉我你要用 a，b 命名。。如果打算这样命名，还是直接用元组吧。）</p><pre><code class="python"># 首先呢，我们创建一个不可变的容器，这容器就叫 Fruit 吧，这个 Fruit 就保存两个值，取名如上
super_fruit = namedtuple(&quot;Fruit&quot;, [&quot;name&quot;, &quot;price&quot;])  # 创建容器
# 保存数据 gogogo
data = super_fruit(name=&quot;apple&quot;, price=13)
# 一个不够，再来一个
data2 = super_fruit(name=&quot;big apple&quot;, price=26)
# 继续访问数据
print(data.name, data.price)
print(data2.name, data2.price)</code></pre><pre><code>apple 13
big apple 26</code></pre><h4 id="划重点-namedtuple"><a href="#划重点-namedtuple" class="headerlink" title="划重点 (namedtuple)"></a>划重点 (namedtuple)</h4><p>通过 namedtuple 我们也能得到不可变的数据结构，并且可以通过属性来进行访问，大大提高了代码的可读性，并且更加 pythonic 。<br>如有元组的情况，如果结构比较复杂的话，强烈推荐使用哦！<br><a href="#namedtuple_advance">namedtuple 进阶</a></p><h3 id="这个特殊的东西我们就先打住，我们换一个新东西-3-6-中的新模块-dataclasses-中的-dataclass-没错，这个也是用来保存数据的，并且可以数据可变-。"><a href="#这个特殊的东西我们就先打住，我们换一个新东西-3-6-中的新模块-dataclasses-中的-dataclass-没错，这个也是用来保存数据的，并且可以数据可变-。" class="headerlink" title="这个特殊的东西我们就先打住，我们换一个新东西 3.6 中的新模块 dataclasses 中的 dataclass(没错，这个也是用来保存数据的，并且可以数据可变)。"></a>这个特殊的东西我们就先打住，我们换一个新东西 3.6 中的新模块 dataclasses 中的 dataclass(没错，这个也是用来保存数据的，并且可以数据可变)。</h3><p><code>dataclass</code> 用来干什么， 老规矩，我们先设想一个场景-用类来保存属性，通过属性来访问值，我们用正常的代码来看看。</p><h3 id="dataclass"><a href="#dataclass" class="headerlink" title="dataclass"></a>dataclass</h3><pre><code class="python"># 假设需要一个对象类，代表测试环境数据库的连接，我们需要给一堆属性用于配置, 并添加默认参数
class TestEnv:
    def __init__(self, port=3306, host=&quot;localhost&quot;, db=&quot;test_database&quot;, tb_name=&quot;table_name&quot;):
        self.port = port
        self.host = host
        self.db = db
        self.tb_name = tb_name
&quot;&quot;&quot;当然，你也可以这样写：
class TestEnv:
    def __init__(self):
        self.port = 3306
        self.host = &quot;localhost&quot;
        self.db = &quot;test_database&quot;
        self.tb_name = &quot;table_name&quot;
&quot;&quot;&quot;
# 我们来点 pythonic 的写法，加上类型注释
class PythonicTestEnv:
    def __init__(self, port: int=3306, host: str=&quot;localhost&quot;, db: str=&quot;test_database&quot;, tb_name: str=&quot;table_name&quot;):
        self.port = port
        self.host = host
        self.db = db
        self.tb_name = tb_name</code></pre><p>我们实例化对象后查看一下属性</p><pre><code class="python">env = TestEnv()
print(env.port)
print(env.tb_name)

env = PythonicTestEnv()
print(env.port)
print(env.tb_name)</code></pre><pre><code>3306
table_name
3306
table_name</code></pre><p>当然，属性与 <code>namedtuple</code> 不同，是可以改变的。</p><pre><code class="python">env.port = 3308
print(env.port)
env</code></pre><pre><code>3308
&gt;&gt;&gt; &lt;__main__.PythonicTestEnv at 0x104092be0&gt;</code></pre><p>所有要保证数据的不可变性的话，还是推荐使用 <code>namedtuple</code>, 但是对于这种纯数据的对象这样写比较繁琐，所以，何不试试新方法～ go！</p><pre><code class="python">from dataclasses import dataclass</code></pre><pre><code class="python">@dataclass
class DCTestEnv:
    port: int=3306
    host: str=&quot;localhost&quot;
    db: str=&quot;test_database&quot;
    tb_name: str=&quot;table_name&quot;</code></pre><pre><code class="python">env = DCTestEnv()
print(env.port)
print(env.tb_name)
env</code></pre><pre><code>3306
table_name
&gt;&gt;&gt;  DCTestEnv(port=3306, host=&#39;localhost&#39;, db=&#39;test_database&#39;, tb_name=&#39;table_name&#39;)</code></pre><p><strong>看，是不是一气呵成，简单方便。</strong><br>细心的同学可能会发现，当对象在交互模式出现时，<strong>输出的结果不一样！</strong><br>没错 <code>dataclass</code> 还帮我们把 <code>__repr__</code> 也重写好了(<strong>划重点</strong>)！是不是很方便！没错 dataclass 最重要的就是 省代码！省代码！省代码！ 重要的事说三遍！方便快捷，选他没错！</p><blockquote><p>但其实不止这些方法，<code>dataclass</code> 还帮我们重写了 __eq__ 什么的，我们也可以重写这些方法。</p></blockquote><p><strong>好了，小技巧引入完了，我们来进入正题，面向对象知识的进阶！</strong></p><h2 id="Python对象模型"><a href="#Python对象模型" class="headerlink" title="Python对象模型"></a>Python对象模型</h2><p>这里我们通过两个对象来引入：</p><ul><li>卡牌</li><li>向量</li></ul><h4 id="卡牌对象-FrenchDeck"><a href="#卡牌对象-FrenchDeck" class="headerlink" title="卡牌对象(FrenchDeck)"></a>卡牌对象(FrenchDeck)</h4><p>这是一副扑克，记录了扑克的所有卡牌。</p><ul><li>有一个 _cards 属性保存了所有的卡牌，每一张卡牌只有花色和卡牌大小</li></ul><p>要是你会怎么设计这个对象呢？<br>我们来看看常规思路。</p><ul><li>因为卡牌比较多，所以这个 _cards 肯定是循环生成的。</li><li>因为每张卡牌固定有两个属性，所以我们用不可变对象来保存能更节省空间。</li><li>不可变对象，要保存花色和卡牌，我们可以用字符串或者元组来实现。</li><li>但是字符串肯定不太合适，花色和大小相关度不是很高，也不便于维护。</li><li>所以我们用元组来实现。</li></ul><p>代码如下：</p><pre><code class="python">class FrenchDeck:
    ranks = [str(i) for i in range(2, 11)] + list(&#39;JDKA&#39;)
    suits = [&quot;黑桃&quot;, &quot;方块&quot;, &quot;梅花&quot;, &quot;红桃&quot;]
    def __init__(self):
        self._cards = [(suit, rank) for suit in self.suits
                     for rank in self.ranks]</code></pre><p><strong>我们实例化对象看看效果</strong></p><pre><code class="python">puke_cards = FrenchDeck()
puke_cards._cards</code></pre><pre><code>[(&#39;黑桃&#39;, &#39;2&#39;),
 (&#39;黑桃&#39;, &#39;3&#39;),
 (&#39;黑桃&#39;, &#39;4&#39;),
 (&#39;黑桃&#39;, &#39;5&#39;),
 (&#39;黑桃&#39;, &#39;6&#39;),
 (&#39;黑桃&#39;, &#39;7&#39;),
 (&#39;黑桃&#39;, &#39;8&#39;),
 (&#39;黑桃&#39;, &#39;9&#39;),
 (&#39;黑桃&#39;, &#39;10&#39;),
 (&#39;黑桃&#39;, &#39;J&#39;),
 (&#39;黑桃&#39;, &#39;D&#39;),
 (&#39;黑桃&#39;, &#39;K&#39;),
 (&#39;黑桃&#39;, &#39;A&#39;),
 (&#39;方块&#39;, &#39;2&#39;),
 (&#39;方块&#39;, &#39;3&#39;),
 (&#39;方块&#39;, &#39;4&#39;),
 (&#39;方块&#39;, &#39;5&#39;),
 (&#39;方块&#39;, &#39;6&#39;),
 (&#39;方块&#39;, &#39;7&#39;),
 (&#39;方块&#39;, &#39;8&#39;),
 (&#39;方块&#39;, &#39;9&#39;),
 (&#39;方块&#39;, &#39;10&#39;),
 (&#39;方块&#39;, &#39;J&#39;),
 (&#39;方块&#39;, &#39;D&#39;),
 (&#39;方块&#39;, &#39;K&#39;),
 (&#39;方块&#39;, &#39;A&#39;),
 (&#39;梅花&#39;, &#39;2&#39;),
 (&#39;梅花&#39;, &#39;3&#39;),
 (&#39;梅花&#39;, &#39;4&#39;),
 (&#39;梅花&#39;, &#39;5&#39;),
 (&#39;梅花&#39;, &#39;6&#39;),
 (&#39;梅花&#39;, &#39;7&#39;),
 (&#39;梅花&#39;, &#39;8&#39;),
 (&#39;梅花&#39;, &#39;9&#39;),
 (&#39;梅花&#39;, &#39;10&#39;),
 (&#39;梅花&#39;, &#39;J&#39;),
 (&#39;梅花&#39;, &#39;D&#39;),
 (&#39;梅花&#39;, &#39;K&#39;),
 (&#39;梅花&#39;, &#39;A&#39;),
 (&#39;红桃&#39;, &#39;2&#39;),
 (&#39;红桃&#39;, &#39;3&#39;),
 (&#39;红桃&#39;, &#39;4&#39;),
 (&#39;红桃&#39;, &#39;5&#39;),
 (&#39;红桃&#39;, &#39;6&#39;),
 (&#39;红桃&#39;, &#39;7&#39;),
 (&#39;红桃&#39;, &#39;8&#39;),
 (&#39;红桃&#39;, &#39;9&#39;),
 (&#39;红桃&#39;, &#39;10&#39;),
 (&#39;红桃&#39;, &#39;J&#39;),
 (&#39;红桃&#39;, &#39;D&#39;),
 (&#39;红桃&#39;, &#39;K&#39;),
 (&#39;红桃&#39;, &#39;A&#39;)]</code></pre><p>emmmm..有点感觉，我们试着随机访问几个元素看看</p><pre><code class="python">from random import randint

for i in range(3):
    card = puke_cards._cards[randint(0, 53)]
    print(card, card[0], card[1])</code></pre><pre><code>(&#39;梅花&#39;, &#39;7&#39;) 梅花 7
(&#39;梅花&#39;, &#39;J&#39;) 梅花 J
(&#39;方块&#39;, &#39;J&#39;) 方块 J</code></pre><blockquote><p>元素比较少，还能勉强猜出意思。我们用刚学的 nametuple 来看看。</p></blockquote><h4 id="nametuple-参与创建卡牌"><a href="#nametuple-参与创建卡牌" class="headerlink" title="nametuple 参与创建卡牌"></a>nametuple 参与创建卡牌</h4><pre><code class="python">import collections

Card = collections.namedtuple(&#39;Card&#39;, [&#39;rank&#39;, &#39;suit&#39;])


class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list(&#39;JQKA&#39;)
    suits = &#39;黑桃 方块 梅花 红桃&#39;.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                       for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]
</code></pre><pre><code class="python">print(FrenchDeck.ranks)  # 生成需要的卡牌列表
FrenchDeck.suits  # 卡牌花色</code></pre><pre><code> [&#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39;, &#39;A&#39;]
 &gt;&gt;&gt; [&#39;黑桃&#39;, &#39;方块&#39;, &#39;梅花&#39;, &#39;红桃&#39;]</code></pre><pre><code class="python">fcards = FrenchDeck()  # 实例化对象
fcards._cards  # 查看以下 nametuple 的出来的卡牌，是不是更加直观好看</code></pre><pre><code>[Card(rank=&#39;2&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;3&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;4&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;5&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;6&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;7&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;8&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;9&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;10&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;J&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;Q&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;K&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;A&#39;, suit=&#39;黑桃&#39;),
 Card(rank=&#39;2&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;3&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;4&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;5&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;6&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;7&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;8&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;9&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;10&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;J&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;Q&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;K&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;A&#39;, suit=&#39;方块&#39;),
 Card(rank=&#39;2&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;3&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;4&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;5&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;6&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;7&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;8&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;9&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;10&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;J&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;Q&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;K&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;A&#39;, suit=&#39;梅花&#39;),
 Card(rank=&#39;2&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;3&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;4&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;5&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;6&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;7&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;8&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;9&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;10&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;J&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;Q&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;K&#39;, suit=&#39;红桃&#39;),
 Card(rank=&#39;A&#39;, suit=&#39;红桃&#39;)]</code></pre><p>同样我们访问元素看看</p><pre><code class="python">for i in range(3):
    card = fcards._cards[randint(0, 53)]
    print(card, card.rank, card.suit)</code></pre><pre><code>Card(rank=&#39;5&#39;, suit=&#39;方块&#39;) 5 方块
Card(rank=&#39;5&#39;, suit=&#39;黑桃&#39;) 5 黑桃
Card(rank=&#39;J&#39;, suit=&#39;红桃&#39;) J 红桃</code></pre><blockquote><p>通过属性访问，是不是可读性提高很多了呢？</p></blockquote><h3 id="奇妙的对象模型"><a href="#奇妙的对象模型" class="headerlink" title="奇妙的对象模型"></a>奇妙的对象模型</h3><h4 id="神奇的魔术方法（magic-mthod）-或者-双下方法（dunder-method）"><a href="#神奇的魔术方法（magic-mthod）-或者-双下方法（dunder-method）" class="headerlink" title="神奇的魔术方法（magic mthod） 或者 双下方法（dunder method）"></a>神奇的魔术方法（magic mthod） 或者 双下方法（dunder method）</h4><p>今天我们介绍两个简单的魔术方法，因为魔术方法很多以后会慢慢添加。</p><ul><li><code>__len__</code></li><li><code>__getitem__</code></li></ul><p>可以看名字直接猜猜意思哦！</p><h4 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h4><pre><code class="python"># len:
class A:
    def __len__(self):
        print(&quot;Attention __len__ is called!!!&quot;)
        return 12</code></pre><p>其实看名字我们就能猜出个八九不离十，肯定和长度有关嘛。首先随便定义一个类，看看有什么神奇的效果！</p><pre><code class="python">test_len = A()
len(test_len)</code></pre><pre><code>Attention __len__ is called!!!
&gt;&gt;&gt;  12</code></pre><p>没错，其实 <code>len(object)</code> 时，就是重载了 <code>object.__len__</code>方法，不过用 <code>len(obj)</code> 看起来更加优雅哦。<br>next one！</p><h4 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h4><pre><code class="python">class B:
    def __getitem__(self, item):
        print(item)
        return &quot;Attention item is calling&quot;</code></pre><pre><code class="python">B()[0]</code></pre><pre><code>0
&gt;&gt;&gt; &#39;Attention item is calling&#39;</code></pre><p>没错 <code>__getitem__</code> 就是当索引对象时重载的方法。<br>当然，我们也可以传一些奇怪的索引给对象！</p><pre><code class="python">B()[&quot;pythonic!&quot;]</code></pre><pre><code>pythonic!
&gt;&gt;&gt;  &#39;Attention item is calling&#39;</code></pre><blockquote><p>!没错！这就变成字典的索引！是不是很神奇呢？<br>但是有些时候重写这两个方法也不是一件容易的事，但是我们可以偷偷懒。<br>如同定义 FrenchDeck 的操作。<br>利用原对象的特性！我们让 FrenchDeck 也具有了长度和索引的技能！</p></blockquote><pre><code class="python">len(fcards)</code></pre><pre><code>52</code></pre><pre><code class="python">fcards[randint(0, 53)]</code></pre><pre><code>Card(rank=&#39;J&#39;, suit=&#39;红桃&#39;)</code></pre><p><strong>如果自定义对象也需要这两个方法的时候，可以重点研究尝试一下！</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学到哪，总结到哪！我们简单回顾一下我们学的：</p><ul><li><a href="#namedtuple">神奇的元组（namedtuple）</a><ul><li>用对象属性访问值的元组！更加 pythonic ！</li></ul></li><li><a href="#dataclass">简便的数据模型 （dataclass）</a><ul><li>几行代码创建一个数据模型类！方便快捷！</li></ul></li><li><a href="#奇妙的对象模型">奇妙的对象模型</a><ul><li><a href="#`__len__`"><code>__len__</code></a></li><li><a href="#`__getitem__`"><code>__getitem__</code></a></li></ul></li></ul><h3 id="一些额外的补充"><a href="#一些额外的补充" class="headerlink" title="一些额外的补充"></a>一些额外的补充</h3><ul><li><h4 id="一些常见的运算魔术方法。"><a href="#一些常见的运算魔术方法。" class="headerlink" title="一些常见的运算魔术方法。"></a>一些常见的运算魔术方法。</h4></li><li><h4 id="namedtuple-的高阶使用。"><a href="#namedtuple-的高阶使用。" class="headerlink" title="namedtuple 的高阶使用。"></a>namedtuple 的高阶使用。</h4></li></ul><p><b>本文地址： <a href="https://dustyposa.github.com/posts/6f4644c4/">https://dustyposa.github.com/posts/6f4644c4/</a></b></p></div><hr><div><p><span><i class="iconfont icon-inbox"></i> <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> &nbsp; </span>&nbsp;&nbsp; <span><i class="iconfont icon-tag"></i> <a class="hover-with-bg" href="/tags/python/">python</a> <a class="hover-with-bg" href="/tags/advance/">advance</a></span></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/posts/1a1d0279/"><i class="fa fa-chevron-left"></i> <span class="hidden-mobile">python向文本中插入文字</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/posts/841d9ffa/"><span class="hidden-mobile">python 请求分析及多提取器 提取数据</span> <span class="visible-mobile">下一篇</span> <i class="fa fa-chevron-right"></i></a></div></div></div><div class="comments" id="comments"><script defer src="https://utteranc.es/client.js" repo="Dustyposa/utterances_comments" issue-term="pathname" label="✨💬✨" theme="github-light" crossorigin="anonymous"></script></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc-start"></div><div id="toc"><p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script><script>$(document).ready((function(){var t=$("#navbar").height(),o=$("#toc"),s=$("#board-ctn"),c=s.offset().top,i=2*c+s.height();$(window).scroll((function(){var s=$("#toc-start").offset().top-t,c=document.body.scrollTop+document.documentElement.scrollTop;s<=c&&c<=i?o.css({display:"block",position:"fixed",top:t}):c<=s?o.css({position:"",top:""}):c>i&&o.css("display","none")})),tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,headingsOffset:-c}),$(".toc-list-item").length>0&&$("#toc > p").css("visibility","visible");var l=s.css("margin-right");$("#toc-ctn").css({right:l})}))</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-163481315-1","auto"),ga("send","pageview")</script><script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script><script>$(document).ready((function(){$("pre").addClass("prettyprint  "),prettyPrint()}))</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","奇妙的对象模型及存储数据模型的技巧&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready((function(){$(".typed-cursor").addClass("h2"),typed.start()}))</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options={placement:"right",visible:"hover",icon:"❡"};var el="h1,h2,h3,h4,h5,h6".split(","),res=[];for(item of el)res.push(".markdown-body > "+item);anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each((function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)}))</script><script>!function(e,t,a){function r(e){var a=t.createElement("div");a.className="heart",n.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}),t.body.appendChild(a)}var n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(e){var a=t.createElement("style");a.type="text/css";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName("head")[0].appendChild(a)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var t="function"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),r(e)}}(),function e(){for(var a=0;a<n.length;a++)n[a].alpha<=0?(t.body.removeChild(n[a].el),n.splice(a,1)):(n[a].y--,n[a].scale+=.004,n[a].alpha-=.013,n[a].el.style.cssText="left:"+n[a].x+"px;top:"+n[a].y+"px;opacity:"+n[a].alpha+";transform:scale("+n[a].scale+","+n[a].scale+") rotate(45deg);background:"+n[a].color+";z-index:99999");requestAnimationFrame(e)}()}(window,document)</script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/ni-j.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>