<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python 编写多进程 socket web静态服务器</title>
    <link href="/2020/04/06/python_server/"/>
    <url>/2020/04/06/python_server/</url>
    
    <content type="html"><![CDATA[<h3 id="服务器模型-C-S模型"><a href="#服务器模型-C-S模型" class="headerlink" title="服务器模型 C/S模型"></a>服务器模型 C/S模型</h3><p><strong>socket</strong> 是什么 ？<br><strong>一种进程间的通信技术 由伯克利大学（BSD） 发明， 才有了当前的互联网</strong></p><p><strong>几乎所有的C/S模型服务器， 底层都是socket实现的， web服务器也不例外， 只是web服务器用了：</strong></p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h4><a id="more"></a><p>用python搭建简易的web服务器：</p><h4 id="1-导入相关模块"><a href="#1-导入相关模块" class="headerlink" title="1. 导入相关模块"></a>1. 导入相关模块</h4><pre><code class="python">import os  # 导入系统模块import socket  # 导入 socket包from multiprocessing import Process  # 导入多进程模块</code></pre><h4 id="2-创建类并初始化"><a href="#2-创建类并初始化" class="headerlink" title="2. 创建类并初始化"></a>2. 创建类并初始化</h4><p><strong>初始化出部分需要的属性 方便之后方法的使用</strong><br>port 主机需要绑定的端口</p><pre><code class="python">class WebServer(object):    BASE_DIR = os.path.join(os.getcwd(), &#39;static&#39;)  # 查询文件夹， 用来查找访问的文件    RESPONSE_STATUS = {200: &#39;OK&#39;, 404: &#39;Not Found&#39;, 403: &#39;Forbid&#39;}  # 设置响应行可选返回状态码， 只选择了部分做演示    def __init__(self, port=8080):        &quot;&quot;&quot;        初始化参数        :param port:        &quot;&quot;&quot;        self.soc = self.create_server(port)  # 初始化socket对象        self.new_fd: socket.socket = ...  # 方便pycharm提示,防止pycharm报波浪线        self.request_dict = {}  # 设置空字典， 用于存储处理过后的请求头        self.response_dict = [(&#39;Server&#39;, &#39;my_server&#39;), (&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)]  # 设置响应头，因为可能有多个Set-Cookie， 所以用列表中的元组存储</code></pre><h4 id="3-初始化socket对象-固定四部曲"><a href="#3-初始化socket对象-固定四部曲" class="headerlink" title="3. 初始化socket对象 固定四部曲"></a>3. 初始化socket对象 固定四部曲</h4><ol><li>创建socket对象</li><li>绑定address， ip及端口</li><li>防止服务器异常时， 端口的占用， 影响服务器的重启</li><li>转成监听模式<pre><code class="python"> # 创建socket对象 def create_server(self, port):     &quot;&quot;&quot;     用来初始化server对象     :return:     &quot;&quot;&quot;     self.soc = socket.socket()  # 创建socket对象     self.soc.bind((&#39;&#39;, port))  # 绑定套接字到address， 一般为 ip+port， 并且host一般是127.0.0.1或者不填(等内核分配)，一般无权绑定非本机ip     self.soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # 接续服务器突然宕掉时，端口暂时不能使用的问题     self.soc.listen(5)  # 转为监听状态 服务器必须     return self.soc</code></pre><h4 id="4-多进程接受请求"><a href="#4-多进程接受请求" class="headerlink" title="4. 多进程接受请求"></a>4. 多进程接受请求</h4></li><li>accept() 从缓存中拿出连接描述符 此处为 阻塞IO 加入子进程</li><li>创建子进程 此处为 阻塞IO 在子进程中处理</li><li>开启子进程</li><li>剪掉主进程对描述符的引用<pre><code class="python"> # 开启多进程 def runserver(self):     &quot;&quot;&quot;     多进程处理请求     :return:     &quot;&quot;&quot;     while True:         self.new_fd, _ = self.soc.accept()  # 从缓存中读取新的请求         fd = Process(target=self.handler)  # 转到子进程中执行         fd.start()  # 开启进程         self.new_fd.close()  # 去掉主进程引用</code></pre><h4 id="5-接受描述符发送的信息"><a href="#5-接受描述符发送的信息" class="headerlink" title="5. 接受描述符发送的信息"></a>5. 接受描述符发送的信息</h4></li></ol><pre><code class="python">    # 接收请求头    def handler(self):        &quot;&quot;&quot;        处理发送过来的信息        :return:        &quot;&quot;&quot;        print(&#39;新的链接到来，&#39;, self.new_fd)        buf: bytes = self.new_fd.recv(1024)  # 读取部分数据，主要用来处理请求行和请求头        if buf:            new_buf = buf.decode(&#39;utf8&#39;)  # 将二进制数据转成str            # 解析字符串            self._request_handler(new_buf)</code></pre><h4 id="6-处理请求头"><a href="#6-处理请求头" class="headerlink" title="6. 处理请求头"></a>6. 处理请求头</h4><ol><li>处理请求行， 推荐使用 splitlines()进行分割， split(‘\r\n’)在跨平台时不好用</li><li>处理请求体</li><li>获取文件路径</li><li>进行后续处理</li></ol><pre><code class="python">    # 解析请求头    def _request_handler(self, data: str):        &quot;&quot;&quot;        浏览器请求 格式固定        请求行: GET / HTTP/1.1\r\n        请求头: Host: 127.0.0.1\r\n               User-Agent: Mozilla5.0...\r\n        请求体: 基本为固定为POST 的内容， 此处不演示        :param data:        :return:        &quot;&quot;&quot;        data = data.splitlines()  # 进行行分割        request_head = data.pop(0).strip()  # 接受请求行        self.request_dict[&#39;Method&#39;], self.request_dict[&#39;Path&#39;], _ = request_head.split(&#39; &#39;)  # 生成请求行字典        # 遍历data部分,得到请求头信息 Host: 127.0.0.1 列表中的格式        new_data = {x[0]: x[1] for x in [i.split(&#39;:&#39;) for i in data if &#39;: &#39; in i]}        # 更新字典        self.request_dict.update(new_data)        # 获取请求路径        self.filename = self.request_dict[&#39;Path&#39;][1:]  # 获取请求的url        os.chdir(self.BASE_DIR)  # 改变查找文件        self._response_handler()</code></pre><h4 id="7-拼接及发送响应头"><a href="#7-拼接及发送响应头" class="headerlink" title="7. 拼接及发送响应头"></a>7. 拼接及发送响应头</h4><ol><li><p>等待状态码的返回</p></li><li><p>根据不同状态吗 拼接不同的响应行</p></li><li><p>拼接响应头</p></li><li><p>发送响应头</p></li><li><p>处理响应体</p><pre><code class="python"># 发送响应头 def _response_handler(self):     &quot;&quot;&quot;     响应体的格式     响应行: HTTP/1.1 200 OK\r\n     响应头: Content-Type:text/html; charset=utf-8\r\n            Server: My_server\r\n     响应体: HTML/JSON/JPG/PNG/MP3.....     &quot;&quot;&quot;     self.status = self._check_request()     response_head = f&quot;HTTP/1.1 {self.status} {self.RESPONSE_STATUS[self.status]}\r\n&quot;  # 组成请求行     response_content = &#39;&#39;.join([i[0] + &#39;: &#39; + i[1] + &#39;\r\n&#39; for i in self.response_dict])  # 组成请求头     response_end = &#39;\r\n&#39;  # 换行  头部结束     self.response = response_head + response_content + response_end     # 发送请求头信息     self.new_fd.send(self.response.encode(&#39;utf8&#39;))     self.send_response()</code></pre><h4 id="8-判断状态码，简单判断，有资源返回200，没有资源返回404"><a href="#8-判断状态码，简单判断，有资源返回200，没有资源返回404" class="headerlink" title="8. 判断状态码，简单判断，有资源返回200，没有资源返回404"></a>8. 判断状态码，简单判断，有资源返回200，没有资源返回404</h4></li><li><p>判断是否是文件</p><pre><code class="python"> @set_status def _check_request(self):     &quot;&quot;&quot;     给出返回值， 403用装饰器装饰     :return:     &quot;&quot;&quot;     if os.path.isfile(self.filename):         return 200     else:         return 404</code></pre><h4 id="9-装饰器添加User-Agent验证"><a href="#9-装饰器添加User-Agent验证" class="headerlink" title="9. 装饰器添加User-Agent验证"></a>9. 装饰器添加User-Agent验证</h4></li><li><p>在类外面定义装饰器函数，</p></li><li><p>进行User-Agent判断</p><pre><code class="python">def set_status(fun): &quot;&quot;&quot; 返回值的装饰器, 增加User-Agent判断代理是否异常， 返回403 :param fun: :return: &quot;&quot;&quot; def change(self, *args, **kwargs):     if len(self.request_dict[&#39;User-Agent&#39;]) &lt; 60:         return 403     else:         return fun(self, *args, **kwargs) return change</code></pre><h4 id="10-发送响应体，关闭连接"><a href="#10-发送响应体，关闭连接" class="headerlink" title="10. 发送响应体，关闭连接"></a>10. 发送响应体，关闭连接</h4></li></ol><ul><li>根据不同的返回值，决定如何返回<pre><code class="python">  # 发送响应体内容  def send_response(self):      if self.status == 200:          # 正常访问页面          with open(self.filename, &#39;rb&#39;) as f:              self.new_fd.send(f.read())      elif self.status == 404:          # 打开404页面          with open(&#39;404.html&#39;, &#39;rb&#39;) as f:              self.new_fd.send(f.read())      elif self.status == 403:          self.new_fd.send(&#39;ForForForbid&#39;.encode(&#39;utf8&#39;))  # 皮一下</code></pre>github上的完整代码 <a href="https://github.com/Dustyposa/segementfault/blob/master/web_server.py" target="_blank" rel="noopener">web_server</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python3</tag>
      
      <tag>server</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
